<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用nw.js打包react项目]]></title>
    <url>%2F2019%2F04%2F09%2Fface_02%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617nw.js原名node-webkit，它通过Chromium内核，可以在node环境下模拟浏览器运行时，因此可以将js封装成独立应用，从而实现跨平台。#### nw.js安装官方地址https://nwjs.io/，选择对应你自己的系统，开发的话可以下载SDK，SDK可以打开控制台，上线之类的可以选择Normal版本。#### 准备index.html文件将react项目build之后，将build目录下的文件拷贝到刚才下载的文件夹里面，和nw.exe同目录#### 准备package.json最后需要新建一个package.json文件，这是nw打包的配置文件和入口文件，最基础的是name，main&#123; name: &apos;nwDemo&apos;, main: &apos;index.html&apos;&#125;将package.json文件拷贝到nw.exe同目录下，运行nw.exe即可]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用React和face-api.js提供面部识别]]></title>
    <url>%2F2019%2F03%2F21%2Fface_01%2F</url>
    <content type="text"><![CDATA[12345678 face-api.js提供了Tiny Face Detector、SSD mobileNet和MTCNN三种模型，此API人脸识别的原理就是一旦检测到一个或多个人脸，人脸检测器模型将返回每个人脸的边界框，告诉我们人脸在图像中的位置。然后利用人脸标志网络对人脸标志进行68个点的标记，在人脸识别网络进行输入前，利用对齐模型确定人脸的中心位置。 人脸识别网络是另一个神经网络返回一个人脸描述符（特征向量包含128个值），我们可以用它来比较和识别图像中的人。就像指纹一样，脸部描述符是每个脸部的独特价值。当我们比较它们时，来自不同图像源的同一个人的人脸描述符应该非常接近。在这个项目中，我们使用欧几里德距离进行比较。如果距离小于我们设定的阈值，我们确定他们可能是同一个人。 （距离越远，信心越高） 通常，系统将每个人的面部描述符与他或她的名称一起存储为标记。当我们提供查询图像时，系统会将新图像的脸部描述符与所有参考描述符进行比较，并识别具有最低图像描述符的人。如果没有比较低于阈值的人，则该人将被识别为未知。 12今天这里实现两个功能。一种是从输入图像中识别，另一种是使用实时视频作为输入。让我们从create-react-app开始，安装react-router-dom，然后启动App 123456create-react-app face-democd face-demoyarn add react-router-domyarn start这时会自动打开默认的页面 1将src/App.js文件用react-router-dom设置一下]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React下拉刷新]]></title>
    <url>%2F2019%2F01%2F15%2Freact_02%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import React, &#123; Component &#125; from &apos;react&apos;;import HttpUtil from &apos;../common/common&apos;import PullRefresh from &apos;reactjs-pull-refresh&apos;export default class NewList extends Component&#123; constructor(props)&#123; super(props); this.state=&#123; hasMore: true, //是否加载更多 stores: [], //数据 page:0, //当前请求的页数 size:10, //每次请求的数量 total: 110 //数据总条数 &#125;; &#125; componentDidMount() &#123; this.getData(this.state.page, this.state.size); &#125; refreshCallback() &#123; let &#123; stores, total, size &#125; = this.state; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result = false; if (Math.random() &gt; 0.1) &#123; result = true; &#125; if (result) &#123; this.setState(&#123; page: 0, hasMore: stores.length &lt;= total &#125;, () =&gt; &#123; this.getData(this.state.page, size); resolve(); &#125;); &#125; else &#123; reject(new Error(&apos;错误&apos;)); &#125; &#125;, 1000); &#125;).then(() =&gt; &#123; console.info(&apos;刷新成功！&apos;); &#125;, () =&gt; &#123; console.info(&apos;刷新失败！&apos;); &#125;); &#125;; loadMoreCallback = () =&gt; &#123; let &#123; stores, total, size &#125; = this.state; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result = false; if (Math.random() &gt; 0.1) &#123; result = true; &#125; if (result) &#123; this.setState(&#123; page: this.state.page + 1, hasMore: stores.length &lt;= total &#125;, () =&gt; &#123; this.getData(this.state.page, size); resolve(); &#125;); &#125; else &#123; reject(new Error(&apos;错误&apos;)); &#125; &#125;, 1000); &#125;).then(() =&gt; &#123; console.info(&apos;加载更多成功！&apos;); &#125;, () =&gt; &#123; console.info(&apos;加载更多失败！&apos;); &#125;); &#125;; getData(page,size) &#123; var self = this; let params = &#123; page: this.state.page, size: this.state.size &#125;; let stores = []; HttpUtil.fetchPost( url, params, (jsonData) =&gt; &#123; if(jsonData.code === 0)&#123; if(page === 0)&#123; self.setState(&#123; stores: jsonData.res.data.record, total: jsonData.res.data.total //这个必须要，这个是数据的总条数 &#125;) &#125;else&#123; self.setState(&#123; stores: self.state.stores.concat(jsonData.res.data.record), total: jsonData.res.data.total //这个必须要，这个是数据的总条数 &#125;) &#125; &#125; &#125;, (err) =&gt; &#123; &#125; ); &#125; render()&#123; const &#123; hasMore, stores &#125; = this.state; const props = &#123; maxAmplitude: 80, debounceTime: 30, throttleTime: 100, deceleration: 0.001, refreshCallback: this.refreshCallback.bind(this), loadMoreCallback: this.loadMoreCallback.bind(this), hasMore &#125;; return ( &lt;div className=&quot;list&quot;&gt; &lt;PullRefresh&#123;...props&#125;&gt; &#123; stores.map((data,i) =&gt; &#123; return &lt;div className=&quot;duc_list&quot; key=&#123;i&#125; &gt; &lt;h3 className=&quot;list_name&quot; &gt;&#123;data.villageName&#125;&lt;/h3&gt; &lt;div className=&quot;list_info&quot;&gt; &lt;img className=&quot;list_img&quot; src=&quot;http://121.40.178.164:4040/react-res/public/uploads/banner/8a2f424c58fd4e9e0158fd6aa04a002c/11.jpg&quot; alt=&quot;&quot;/&gt; &lt;div className=&quot;list_rent&quot;&gt;¥&lt;span&gt;&#123;data.salePrice&#125;&lt;/span&gt;/月&lt;/div&gt; &lt;div className=&quot;list_rom&quot;&gt; &lt;span className=&quot;list_rom_area&quot;&gt;&lt;span&gt;&#123;data.room&#125;&lt;/span&gt;室 &lt;span&gt;&#123;data.hall&#125;&lt;/span&gt;厅 &lt;span&gt;&#123;data.useArea&#125;&lt;/span&gt;㎡&lt;/span&gt; &lt;span className=&quot;list_avage&quot;&gt;&#123;data.advantage&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;list_address&quot;&gt; &lt;img src=&#123;require(&apos;../images/sub-icon.png&apos;)&#125; /&gt; &lt;span className=&quot;list_address_info&quot;&gt;&#123;data.address&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#125;) &#125; &lt;div className=&quot;line&quot;&gt;&lt;/div&gt; &lt;/PullRefresh&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android版本名称、版本号、API level对应关系]]></title>
    <url>%2F2019%2F01%2F15%2Fandroid_01%2F</url>
    <content type="text"><![CDATA[- Code name Version API level 1 no code name 1.0 API level 1 2 no code name 1.1 API level 2 3 Cupcake 1.5 API level 3,NDK 1 4 Donut 1.6 API level 4,NDK 2 5 Eclair 2.0 API level 5 6 Eclair 2.0.1 API level 6 7 Eclair 2.1 API level 7,NDK3 8 Froyo 2.2.x API level 8,NDK 4 9 Gingerbread 2.3-2.3.2 API level 9,NDK5 10 Gingerbread 2.3.3-2.3.7 API level 10 11 Honeycomb 3.0 API level 11 12 Honeycomb 3.1 API level 12,NDK 6 13 Honeycomb 3.2x API level 13 14 Ice Cream Sandwich 4.0.1-4.0.2 API level 14,NDK 7 15 Ice Cream Sandwich 4.0.3-4.0.4 API level 15,NDK 8 16 Jelly Bean 4.1x API level 16 17 Jelly Bean 4.2x API level 17 18 Jelly Bean 4.3x API level 18 19 Jelly Bean 4.4-4.4.4 API level 19 20 Lollipop 5.0 API level 21 21 Lollipop 5.1 API level 22 22 Marshmallow 6.0 API level 23 23 Nougat 7.0 API level 24 24 Nougat 7.1.1 API level 25]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超过固定宽度(或行数)显示...(或省略)]]></title>
    <url>%2F2019%2F01%2F15%2Fcss_02%2F</url>
    <content type="text"><![CDATA[作为前端经常遇到的一个需求。对于一些比较长的文本做限制，不显示，或者显示省略号。今天整理一下。 1、超出固定长度显示…123456.class &#123; width: 400px; overflow: hidden; //这个是设置隐藏的。还有其他的，例如scroll，是超出固定长度，底部显示滚动条的。 text-overflow: ellipsis; //这个就是设置直接隐藏掉文字，还是显示...的。当前是显示省略号，直接省略是clip。 display: inline-block; //根据不同标签display值，有的不用加&#125; 2、超出固定行数显示…超出固定行数。显示省略号，和上面差不多。overflow和text-overflow见上方解释。 1234567.class &#123; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; //这里就是设置超出几行隐藏 -webkit-box-orient: vertical; display: -webkit-box; //根据不同标签display，有的不用加。或者设置成别的属性，自己可以随便试试&#125; 巨坑提醒(多行隐藏)有的时候，你按照上面的设置。就是不生效。或者本地生效了，react（或者vue）打包到服务器上就不生效了。你可以在控制台看看。是不是-webkit-box-orient这个属性消失了。如果是这样的话，请看下面的解决方法。 12345678910111213//办法1直接在style里面写上display: -webkit-box; 就行//办法2.class &#123; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; /* autoprefixer: off */ //对，就是加这两个注释就行. -webkit-box-orient: vertical; /* autoprefixer: on */ display:-webkit-box;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css3隔行变色]]></title>
    <url>%2F2019%2F01%2F15%2Fcss_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657div:nth-of-type(odd)&#123;background:#fff&#125; /*奇数行*/div:nth-of-type(even)&#123;background:#000&#125; /*偶数行 */div:nth-child(4n+1)&#123;background:#fff&#125; /*从第一行开始算起 每隔四个（包含第四个）使用此样式*/div:nth-child(4n+2)&#123;background:#fff&#125; /*从第二行开始算起 每隔四个（包含第四个）使用此样式*/&lt;strong&gt;E:nth-child(n)&lt;/strong&gt;找出E元素,且它是你北朝鲜绵第n个子元素.n可以是数字(1,2,3),关键字(odd,even),公式(2n,2n+3),数字是从1开始的,不是0.如:tr:nth-child(3)匹配所有表格里第3行的trtr:nth-child(2n+1)匹配所有表格的奇数行tr:nth-child(2n)匹配所有的偶数行tr:nth-child(odd)匹配所有的奇数行tr:nth-child(even)匹配所有的偶数行&lt;strong&gt;E:nth-last-child(n)&lt;/strong&gt;选择E元素,且它是父元素的倒数第n个子元素&lt;strong&gt;E:nth-of-type(n)&lt;/strong&gt;选择E元素,且它是父元素所有子元素中类型为E的子元素集合中的第n个,n可以是数字(1,2,3),关键字(odd,even),公式(2n,2n+3),数字是从1开始的,不是0.如p:nth-of-type(2)匹配出,&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;中第二个p元素&lt;strong&gt;E:nth-last-of-type(n)&lt;/strong&gt;选择E元素,且它是父元素的倒数第n个子节点&lt;strong&gt;E:last-child&lt;/strong&gt;找出E元素,且它是父元素中的最后一个字节点&lt;strong&gt;E:first-of-tpe&lt;/strong&gt;找出E元素,且它是父元素中是第一个该类型的元素,如p:first-of-type匹配&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;中的第一个p元素.&lt;strong&gt;E:last-of-type&lt;/strong&gt;找出E元素,且它是父元素中的最后一个该类型的元素.如:p:last-of-type匹配,&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;中的最后一个p元素,它同E:nth-last-of-tpe(1)意义相同&lt;strong&gt;E:only-child&lt;/strong&gt;找出父元素中只包括一个的子元素,且该元素是E&lt;strong&gt;E:only-of-type&lt;/strong&gt;选择其父元素只包含一个同类型的子元素,且该子元素匹配E.如p:only-of-type匹配&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;中的p,因为div中只包括一个p元素&lt;strong&gt;E:empty&lt;/strong&gt;匹配E元素,且该元素不包含子节点,注意,文字也属于节点]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac显示隐藏文件]]></title>
    <url>%2F2019%2F01%2F15%2Fmac_01%2F</url>
    <content type="text"><![CDATA[第一种：在macOS Sierra, 我们可以使用快捷键⌘⇧.(Command + Shift + .)来快速(在Finder中)显示和隐藏文件 第二种在终端使用： 1234//显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true//不显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决bootstrap模态框切换时页面抖动or页面滚动条]]></title>
    <url>%2F2019%2F01%2F15%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap为了让所有的页面(这里指内容溢出和不溢出)显示效果一样，采取的方法如下: 当Modal显示时，设置 1234body &#123; overflow: hidden; margin-right: 15px&#125; (设置15px是因为浏览器的滚动条占位时15px) 在modal显示时给body添加 1234.modal-open &#123; overflow: auto; overflow-y: scroll;&#125; 这样设置的效果是： 1、当页面内容超出(即页面本身存在滚动条)，则modal弹出后，原body滚动禁止，body的margin-right和modal的滚动条位置重叠，此时页面是不会出现抖动现象的。2、当页面内容未超出(即页面本身不存在滚动条)，则modal弹出后，由于body设置了margin-right，会使得页面向左偏移，当modal关闭后，body的margin-right为0，页面向右偏移，就出现页面抖动。 根据上面的描述，解决页面抖动的思路是： 根据scrollHeight和clientHeight，分别在modal加载前和关闭时调整body的overflow、margin-right和.modal的overflow属性，以覆盖bootstrap.css中的样式 函数如下： 1234//解决Modal弹出时页面左右移动问题最佳的办法应该是CSS：引用@僵叔叔的答案：body&#123; overflow: auto !important;&#125; .modal&#123; overflow: auto !important;&#125;]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React下拉刷新]]></title>
    <url>%2F2019%2F01%2F15%2Freact_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import React, &#123; Component &#125; from &apos;react&apos;;import HttpUtil from &apos;../common/common&apos;import PullRefresh from &apos;reactjs-pull-refresh&apos;export default class NewList extends Component&#123; constructor(props)&#123; super(props); this.state=&#123; hasMore: true, //是否加载更多 stores: [], //数据 page:0, //当前请求的页数 size:10, //每次请求的数量 total: 110 //数据总条数 &#125;; &#125; componentDidMount() &#123; this.getData(this.state.page, this.state.size); &#125; refreshCallback() &#123; let &#123; stores, total, size &#125; = this.state; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result = false; if (Math.random() &gt; 0.1) &#123; result = true; &#125; if (result) &#123; this.setState(&#123; page: 0, hasMore: stores.length &lt;= total &#125;, () =&gt; &#123; this.getData(this.state.page, size); resolve(); &#125;); &#125; else &#123; reject(new Error(&apos;错误&apos;)); &#125; &#125;, 1000); &#125;).then(() =&gt; &#123; console.info(&apos;刷新成功！&apos;); &#125;, () =&gt; &#123; console.info(&apos;刷新失败！&apos;); &#125;); &#125;; loadMoreCallback = () =&gt; &#123; let &#123; stores, total, size &#125; = this.state; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result = false; if (Math.random() &gt; 0.1) &#123; result = true; &#125; if (result) &#123; this.setState(&#123; page: this.state.page + 1, hasMore: stores.length &lt;= total &#125;, () =&gt; &#123; this.getData(this.state.page, size); resolve(); &#125;); &#125; else &#123; reject(new Error(&apos;错误&apos;)); &#125; &#125;, 1000); &#125;).then(() =&gt; &#123; console.info(&apos;加载更多成功！&apos;); &#125;, () =&gt; &#123; console.info(&apos;加载更多失败！&apos;); &#125;); &#125;; getData(page,size) &#123; var self = this; let params = &#123; page: this.state.page, size: this.state.size &#125;; let stores = []; HttpUtil.fetchPost( url, params, (jsonData) =&gt; &#123; if(jsonData.code === 0)&#123; if(page === 0)&#123; self.setState(&#123; stores: jsonData.res.data.record, total: jsonData.res.data.total //这个必须要，这个是数据的总条数 &#125;) &#125;else&#123; self.setState(&#123; stores: self.state.stores.concat(jsonData.res.data.record), total: jsonData.res.data.total //这个必须要，这个是数据的总条数 &#125;) &#125; &#125; &#125;, (err) =&gt; &#123; &#125; ); &#125; render()&#123; const &#123; hasMore, stores &#125; = this.state; const props = &#123; maxAmplitude: 80, debounceTime: 30, throttleTime: 100, deceleration: 0.001, refreshCallback: this.refreshCallback.bind(this), loadMoreCallback: this.loadMoreCallback.bind(this), hasMore &#125;; return ( &lt;div className=&quot;list&quot;&gt; &lt;PullRefresh&#123;...props&#125;&gt; &#123; stores.map((data,i) =&gt; &#123; return &lt;div className=&quot;duc_list&quot; key=&#123;i&#125; &gt; &lt;h3 className=&quot;list_name&quot; &gt;&#123;data.villageName&#125;&lt;/h3&gt; &lt;div className=&quot;list_info&quot;&gt; &lt;img className=&quot;list_img&quot; src=&quot;http://121.40.178.164:4040/react-res/public/uploads/banner/8a2f424c58fd4e9e0158fd6aa04a002c/11.jpg&quot; alt=&quot;&quot;/&gt; &lt;div className=&quot;list_rent&quot;&gt;¥&lt;span&gt;&#123;data.salePrice&#125;&lt;/span&gt;/月&lt;/div&gt; &lt;div className=&quot;list_rom&quot;&gt; &lt;span className=&quot;list_rom_area&quot;&gt;&lt;span&gt;&#123;data.room&#125;&lt;/span&gt;室 &lt;span&gt;&#123;data.hall&#125;&lt;/span&gt;厅 &lt;span&gt;&#123;data.useArea&#125;&lt;/span&gt;㎡&lt;/span&gt; &lt;span className=&quot;list_avage&quot;&gt;&#123;data.advantage&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;list_address&quot;&gt; &lt;img src=&#123;require(&apos;../images/sub-icon.png&apos;)&#125; /&gt; &lt;span className=&quot;list_address_info&quot;&gt;&#123;data.address&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#125;) &#125; &lt;div className=&quot;line&quot;&gt;&lt;/div&gt; &lt;/PullRefresh&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Naitve 性能优化]]></title>
    <url>%2F2019%2F01%2F15%2Frn_01%2F</url>
    <content type="text"><![CDATA[1、利用shouldComponentUpdate函数优化react性能以及引入immutable库的必要性(也适用于react-native)123setState()函数在任何情况下都会导致组件重渲染吗？如果setState()中参数还是原来没有发生任何变化的staten？如果组件的state没有变化，并且从父组件接收的props也没有变化，那它就一定不会重渲染吗？如果1，2两种情况下都会导致重渲染，我们该如何避免这种冗杂的操作，从而优化性能？ 参考 https://www.cnblogs.com/penghuwan/p/6707254.html]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Native解决'libgnustl_shared.so is 32-bit instead if 64-bit'报错]]></title>
    <url>%2F2019%2F01%2F15%2Frn_02%2F</url>
    <content type="text"><![CDATA[React Native项目在64位Android手机上运行，会提示“/data/data/com.xxx.xxx/lib-main/libgnustl_shared.so”is 32-bit instead of 64-bit这个错误。 解决方法就是取消掉所有64位的.so文件，全部加载32位的就可以了，下面是步骤 在项目的根部录的gradle.properties里面添加一行代码，android.useDeprecatedNdk = true. 在build.gradle文件里添加以下代码： 12345678910111213android &#123; ... defaultConfig &#123; ... ndk &#123; abiFilters: &quot;armeabi-v7a&quot;,&quot;x86&quot; &#125; packagingOptions &#123; exclude &quot;lib/arm64-v8a/librealm-jni.so&quot; &#125; &#125;&#125;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Naitve 错误集锦]]></title>
    <url>%2F2019%2F01%2F15%2Frn_03%2F</url>
    <content type="text"><![CDATA[1、在android华为手机上运行React-native工程时出现了如下错: 1报错：unable to load script from assets &apos;index.android.bundle&apos;, make sure your bundle is packaged correctly or youu’re running a packager server 解决办法： 1、在Android/app/src/main目录下创建一个空的assets文件夹 2、进入项目跟目录执行下面代码: 1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/ 1运行完毕后assets文件夹下会多出index.android.bundle和index.android.bundle.meta两个文件 重新运行 总结:index.android.bundle是用来调用原生控件的js脚本，每次当改变index.android.js,都需要使用上面的代码片段，来及时的更新index.android.bundle文件，然后打包才可以把新的index.android.js应用上，所以没有index.android.bundle文件时，React-Native项目时无法运行的。]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端开发自适应解决方案（阿里团队高清方案）]]></title>
    <url>%2F2019%2F01%2F15%2Fmobile_01%2F</url>
    <content type="text"><![CDATA[移动端自适应方案有很多1、流式布局 也就是固定高度，宽度是用百分比的方法，这种方法会导致一些元素在大屏手机上拉伸严重的情况，影响视觉效果，只有在很少一部分手机上能完美的展示设计师想要的效果。 2、固定宽度做法 比如早期的淘宝webpage，页面设置成320的宽度，超出部分留白，在大屏幕手机上，就会出现两条大白边，分辨旅高的手机，页面看起来就会特别小，按钮，文字也很小。 3、响应式做法 用一些css框架，比如bootstrap，或者juqeryUI，使用媒体查询，这种方式维护成本高，很少有大型网站使用这种布局。 4、设置viewport进行缩放 天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。不过有时候使用过程中缩放会导致有些页面元素会糊。 5、rem布局 rem是css3新引入的单位，在pc端会有兼容问题，对移动端比较友好。简而言之就是通过动态设置html跟元素的fontsize，等比缩放元素大小来自适应移动设备。 1234567891011121314151617181920212223242526272829303132333435! function(e) &#123; function t(a) &#123; if (i[a]) return i[a].exports; var n = i[a] = &#123; exports: &#123;&#125;, id: a, loaded: !1 &#125;; return e[a].call(n.exports, n, n.exports, t), n.loaded = !0, n.exports &#125; var i = &#123;&#125;; return t.m = e, t.c = i, t.p = &quot;&quot;, t(0)&#125;([function(e, t) &#123; &quot;use strict&quot;; Object.defineProperty(t, &quot;__esModule&quot;, &#123; value: !0 &#125;); var i = window; t[&quot;default&quot;] = i.flex = function(e, t) &#123; var a = e || 100, n = t || 1, r = i.document, o = navigator.userAgent, d = o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i), l = o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i), c = l &amp;&amp; parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;), 10) &gt;= 80, p = navigator.appVersion.match(/(iphone|ipad|ipod)/gi), s = i.devicePixelRatio || 1; p || d &amp;&amp; d[1] &gt; 534 || c || (s = 1); var u = 1 / s, m = r.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;); m || (m = r.createElement(&quot;meta&quot;), m.setAttribute(&quot;name&quot;, &quot;viewport&quot;), r.head.appendChild(m)), m.setAttribute(&quot;content&quot;, &quot;width=device-width,user-scalable=no,initial-scale=&quot; + u + &quot;,maximum-scale=&quot; + u + &quot;,minimum-scale=&quot; + u), r.documentElement.style.fontSize = a / 2 * s * n + &quot;px&quot; &#125;, e.exports = t[&quot;default&quot;]&#125;]);flex(100, 1); 代码原理1、根据设备屏幕的DPR(设备像素比，比如dpr=2时，表示一个css像素由2x2个物理像素点组成)动态设置html的font-size。2、同事根据设备DPR调整页面的缩放值，进而达到高清效果。 方案优势1、引用简单，方便布局(只要把js代码贴到head标签里面，就可以使用了，设计稿一般是640或者750，不需要进行单位换算，直接用设计稿的尺寸就可以，比如设计稿又一个btn的高度为80px，宽度为120px，高清方案默认1rem=100px，那么btn的宽度就设置为:) 1234.btn &#123; width: 0.8rem, height: 1.2rem&#125; 2、根据设备屏幕的DPR，自动设置最合适的高清缩放。保证了不同设备视觉体验的一致性。3、有效解决移动端真是1px问题(这里的1px是设备屏幕上的物理像素) 1234567注意：并不是所有用px的地方都要用rem，rem布局只针对固定宽度。依需求而定，比如淘宝页面底下的tabar，和头部的搜索区域，都是用百分比来布局的，或者flex和模型，当在ipad上打开的时候就可以看见，头部和tab是撑满全屏的。中间的主要内容（最外部的容器）要设置一个max-width，demo设置的是max-width：10rem，这里我不太明白为什么要设置成10rem，有弄明白的小伙伴希望能告诉我。谢谢（已解决，和设置最外层宽度为100%是一样的道理，10rem 可以适配到所有手机设备。1000%可以适配ipad，demo试试就知道了）（应用了此方案，不管设计图多宽（当然，一般宽度为750，640也可以），最外层的div宽度设为100%就行，然后就可以愉快的布局了，不会出现你说的白边的情况。）对于尺寸比较大的元素，应该考虑用百分比。rem做单位的元素在哪种设备下都是固定大小，这点必须牢记！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657可能遇到的问题：1.问：为啥手机网页效果图宽度是要640或者750的，我非得弄个666的不行咩？答：老实说当然可以，不过为了规范，640或者750是相对合适的。拿Iphone 5s 举例，它的css像素宽度是320px，由于它的dpr=2，所以它的物理像素宽度为320 × 2 = 640px，这也就是为什么，你在5s上截了一张图，在电脑上打开，它的原始宽度是640px的原因。那 iphone 6 的截图宽度呢？ 375 × 2 = 750那 iphone 6 sp 的截图宽度呢？ 414 × 3 = 1242以此类推，你现在能明白效果图为什么一般是 640 ，750 甚至是 1242 的原因了么？（真没有歧视安卓机的意思。。。）2.问：宽度用rem写的情况下， 在 iphone6 上没问题， 在 iphone5上会有横向滚动条，何解？答：假设你的效果图宽度是750，在这个效果图上可能有一个宽度为7rem（高清方案默认 1rem = 100px）的元素。我们知道，高清方案的特点就是几乎完美还原效果图，也就是说，你写了一个宽度为 7rem 的元素，那么在目前主流移动设备上都是7rem。然而，iphone 5 的宽度为640，也就是6.4rem。于是横向滚动条不可避免的出现了。怎么办呢？ 这是我目前推荐的比较安全的方式：如果元素的宽度超过效果图宽度的一半（效果图宽为640或750），果断使用百分比宽度，或者flex布局。就像把等屏宽的图片宽度设为100%一样。3.问：不是 1rem = 100px吗，为什么我的代码写了一个宽度为3rem的元素，在电脑端的谷歌浏览器上宽度只有150px?答：先说高清方案代码，再次强调咱们的高清方案代码是根据设备的dpr动态设置html 的 font-size，如果dpr=1(如电脑端），则html的font-size为50px，此时 1rem = 50px如果dpr=2(如iphone 5 和 6），则html的font-size为100px，此时 1rem = 100px如果dpr=3(如iphone 6 sp），则html的font-size为150px，此时 1rem = 150px如果dpr为其他值，即便不是整数，如3.4 , 也是一样直接将dpr 乘以 50 。再来说说效果图，一般来讲，我们的效果图宽度要么是640，要么是750，无论哪一个，它们对应设备的dpr=2，此时，1 rem = 50 × 2 = 100px。这也就是为什么高清方案默认1rem = 100px。而将1rem默认100px也是好处多多，可以帮你快速换算单位，比如在750宽度下的效果图，某元素宽度为53px，那么css宽度直接设为53/100=0.53rem了。然而极少情况下，有设计师将效果图宽定为1242px，因为他手里只有一个iphone 6 sp (dpr = 3)，设计完效果图刚好可以在他的iphone 6 sp里查看调整。一切完毕之后，他将这个效果图交给你来切图。由于这个效果图对应设备的dpr=3，也就是1rem = 50 × 3 = 150px。所以如果你量取了一个宽度为90px的元素，它的css宽度应该为 90/150=0.6rem。由于咱们的高清方案默认1rem=100px，为了还原效果图，你需要这样换算。当然，一个技巧就是你可以直接修改咱们的高清方案的默认设置。在代码的最后 你会看到 flex(100, 1) ，将其修改成flex(66.66667, 1)（感谢简友：V旅行指出此处错误！ 2017/3/24）就不用那么麻烦的换算了，此时那个90px的直接写成0.9rem就可以了。4.问：高清方案在微信上，有时候字体会不受控制变的很大，怎么办？答：点我，这是我对该问题的总结5.问：我在底部导航用的flex感觉更合适一些，请问这样子混着用可以吗？答：咱们的rem适合写固定尺寸。其余的根据需要换成flex或者百分比。源码示例中就有这三种的综合运用。6.问：在高清方案下，一个标准的，较为理想的宽度为640的页面效果图应该是怎样的？7.这个会和bootstrap冲突。解决办法：1，将bootstrap 中，凡是用到px的单位一律换成rem2，如果你有使用webpack，建议使用将css转成rem的包（postcss-pxtorem）将自动完成第一步的操作。8.@2x和@3x的图片还要判断不同的dpr下用不同的图片。Normalize.css 是一个可以定制的CSS文件，它让不同的浏览器在渲染网页元素的时候形式更统一。Normalize.css 能干什么：保留有用的默认值，不同于许多 CSS 的重置标准化的样式，适用范围广的元素。纠正错误和常见的浏览器的不一致性。一些细微的改进，提高了易用性。使用详细的注释来解释代码。支持的浏览器：Google Chrome (latest)Mozilla Firefox (latest)Mozilla Firefox ESROpera (latest)Apple Safari 6+Internet Explorer 8+ 引用于https://www.jianshu.com/p/07669cb3e7c5]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Native动画]]></title>
    <url>%2F2019%2F01%2F15%2Frn_04%2F</url>
    <content type="text"><![CDATA[前言最近项目要做小游戏，小游戏当然就少不了动画了，一开始打算用h5做，但是考虑到内嵌h5坑可能有点多，所以最后还是选择react native的动画（项目本身就是react native写的，之后用rn代表react naitve） 1、requestAnimationFrame12345678910111213141516171819202122232425262728293031323334353637383940414243444546export default class demo1 Component &#123; constructor(props) &#123; super(props); this.state = &#123; width: 100, height: 100 &#125;; &#125; startAnimation() &#123; let count = 0; let &#123; width, height &#125; = this.state; requestAnimationFrame(() =&gt; &#123; this.setState(&#123; widthL: width + 1, height: height + 1 &#125;) &#125;) &#125; render() &#123; let &#123; width, height &#125; = this.state; return( &lt;View style = &#123; styles.container &#125;&gt; &lt;Image source = &#123;require(./icon.jpg)&#125; style = &#123;&#123; width: width, height: height &#125;&#125; /&gt; &lt;TouchableOpacity style = &#123; styles.instructions &#125; onPress = &#123;()=&gt;this.startAnimation()&#125; &gt; &lt;Text style = &#123;&#123; alignSelf: &apos;center&apos;, color: &apos;#fff&apos; &#125;&#125;&gt; click me! &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 这个方式实现的动画有几个问题： 实现方式是通过不断销毁、创建视图来完成，一方面如果你的视图的数据是动态获取的，那么就需要以合适的方式恢复数据；另一方面，这种方式必然造成性能和内存开销的问题。 如果需要刷新的View的层级比较深，那么这种方式会带来严重的性能问题。 requestAnimationFrame毕竟是web上css的用法，在手机上，动画的效果比较生硬，如果需要‘弹性动画’，‘淡入淡出’等效果，则是比较难以实现的（需要辅助各种函数）。 2、setNativeProps 如果执意使用修改state的方式，觉得这种方式更符合当前需求对动画的控制，那么则应当使用原生组件的setNativeProps方法来做对应实现，它会直接修改组件底层特性，会重绘组件，因此性能也远胜动态修改组件内联style的方法。我们稍微修改下startAnimation方法： 12345678910111213startAnimation() &#123; var count = 0; while (++count &lt; 50) &#123; requestAnimationFrame(() = &gt;&#123; this.refs.image.setNativeProps(&#123; style: &#123; width: this.state.width++, height: this.state.height++ &#125; &#125;); &#125;); &#125;&#125; 其中this.refs.image指向的是image视图，效果比上面的好多了。 优点：setNativeProps直接修改组件底层特性，不会重绘组件，因此性能也远胜动态修改组件内联style的方法。 缺点： setNativeProps属于原生视图的方法，如果我们使用一个动画，单纯只是为了跟踪它的值，那么这个方法有点不合时宜。 还是和上面一种方式一样，如果需要实现‘弹性动画’，‘淡入淡出’等效果，则还是比较麻烦的。 3、LayoutAnimation当布局变化时，自动将视图运动到它们新的位置上。一个常用的调用此API的办法是调用LayoutAnimation.configureNext(config)，然后调用setState。其中conf参数格式参考： 1234567891011&#123; duration: 700, //持续时间 create: &#123; //若是新布局的动画类型 type: &apos;linear&apos;, //线性模式 property: &apos;opacity&apos; //动画属性，除了opacity还有一个scaleXY可以配置 &#125;, update: &#123; //若是布局更新的动画类型 type: &apos;spring&apos;, //弹跳模式 springDamping: 0.4 //弹跳阻尼系数 &#125;&#125; 其中动画type的类型可枚举为： 123456spring //弹跳linear //线性easeInEaseOut //缓入缓出easeIn //缓入easeOut //缓出keyboard // 键入 要注意的时，安卓平台使用LayoutAnimation动画必须加上这么一句代码(否则动画会失效): 1UIManager.setLayoutAnimationEnabledExperimental &amp;&amp; UIManager.setLayoutAnimationEnabledExperimental(true); 于是我们一开始的动画就可以这么来写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export default class demo2 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; w: 200, h: 20 &#125;; &#125; _onPress() &#123; LayoutAnimation.configureNext(&#123; duration: 700, create: &#123; type: &apos;linear&apos;, property: &apos;opacity&apos; &#125;, update: &#123; type: &apos;spring&apos;, springDamping: 0.4 &#125; &#125;); this.setState(&#123; w: this.state.w + 30, h: this.state.h + 30 &#125;) &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125; &#125; 这样动画灵活和流畅多了，我们上面看到的仅仅是局部更新的情况，我们来看看新布局被创建（有新组建加入到视图上）的情况如何： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default class demo3 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; showNewOne: false, w: 200, h: 20 &#125;; &#125; _onPress() &#123; LayoutAnimation.configureNext(&#123; duration: 1200, create: &#123; type: &apos;linear&apos;, property: &apos;opacity&apos; //注意这里，我们设置新布局被创建时的动画特性为透明度 &#125;, update: &#123; type: &apos;spring&apos;, springDamping: 0.4 &#125; &#125;); this.setState(&#123;w: this.state.w + 30, h: this.state.h + 30, showNewOne : true&#125;) &#125; render() &#123; let &#123; showNewOne &#125; = this.state; let newOne = showNewOne ? ( &lt;View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;new one&lt;/Text&gt; &lt;/View&gt; ) : null; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/View&gt; &#123;newOne&#125; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 4、Animated通过Animated我们可以在确保性能良好的前提下创造更为灵活丰富且易维护的动画。不同于上述的动画实现方式，我们得在 Animated.View、Animated.Text 或 Animated.Image 动画组件上运用 Animate 模块的动画能力(如果有在其他组件上的需求，可以使用Animated.createAnimatedComponent方法来对其它类型的组件创建动画)下面来个简单的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Easing, Animated, TouchableOpacity,&#125; from &apos;react-native&apos;const _animateHandler;export default class demo4 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; opacityAnmValue: new Animated.Value(0) &#125;; &#125; componentDidMount() &#123; _animateHandler = Animated.timing( this.state.opacityAnmValue, &#123; toValue: 1, //透明度动画最终值 duration: 3000, easing: Easing.bezier(0.15,0.73,0.37,1.2) //缓冲函数 &#125; ) &#125; _onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start() &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 20, opacity: this.state.opacityAnmValue&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity &gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; &#125;, content: &#123; justifyContent: &apos;center&apos;, backgroundColor: &apos;yellow&apos;, &#125;, button: &#123; marginTop: 10, paddingVertical: 10, paddingHorizontal: 20, backgroundColor: &apos;black&apos; &#125;, buttonText: &#123; color: &apos;white&apos;, fontSize: 16, fontWeight: &apos;bold&apos;, &#125;&#125;) 点击按钮后,Animated.View会以bezier曲线形式执行时长3秒的透明度动画(由0到1): 1、以 new Animated.Value(0) 实例化动画的初始值给state： 1234this.state = &#123; //设置透明度动画初始值 opacityAnmValue: new Animated.Value(0)&#125; 2、通过 Animated.timing 我们定义了一个动画事件，在后续可以以 .start() 或 .stop() 方法来开始/停止该动画： 1234567componentDidMount() &#123; _animateHandler = Animated.timing(this.state.opacityAnmValue, &#123; toValue: 1, //透明度动画最终值 duration: 3000, //动画时长3000毫秒 easing: Easing.bezier(0.15, 0.73, 0.37, 1.2) &#125;)&#125; 我们在点击事件中触发了动画的.start方法让它跑起来: 123_onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start()&#125; start 方法接受一个回调函数，会在动画结束时触发，并传入一个参数 {finished: true/false}，若动画是正常结束的，finished 字段值为true，若动画是因为被调用 .stop() 方法而提前结束的，则 finished 字段值为false。 3、动画的绑定是在 上的，我们把实例化的动画初始值传入 style 中： 123&lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 20, opacity: this.state.opacityAnmValue&#125;]&#125;&gt;&lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt;&lt;/Animated.View&gt; 然后。。。就没有然后了，很简单吧。 这里需要讲一下的应该是定义动画事件的Animated.timing(animateValue, conf) 方法，其中设置参数格式为： 12345&#123; duration: 动画持续的时间（单位是毫秒），默认为500。 easing：一个用于定义曲线的渐变函数。阅读Easing模块可以找到许多预定义的函数。iOS默认为Easing.inOut(Easing.ease)。 delay: 在一段时间之后开始动画（单位是毫秒），默认为0。&#125; 这里提及的 Easing 动画函数模块在 react-native/Libraries/Animated/src/ 目录下，该模块预置了 linear、ease、elastic、bezier 等诸多缓动特性，有兴趣可以去了解。 另外除了 Animated.timing，Animated 还提供了另外两个动画事件创建接口： 1、Animated.spring(animateValue, conf) —— 基础的单次弹跳物理模型，支持origami标准，conf参考： 1234&#123; friction: 控制“弹跳系数”、夸张系数，默认为7。 tension: 控制速度，默认40。&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Easing, Animated, TouchableOpacity,&#125; from &apos;react-native&apos;let _animateHandler;export default class demo5 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; bounceValue : new Animated.Value(0) //设置缩放动画初始值 &#125;; &#125; componentDidMount() &#123; this.state.bounceValue.setValue(1.5); // 设置一个较大的初始值 _animateHandler = Animated.spring(this.state.bounceValue, &#123; toValue: 1, friction: 8, tension: 35 &#125;) &#125; _onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start() &#125; _reload() &#123; AppRegistry.reload() &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 20, transform: [&#123;scale: this.state.bounceValue&#125;]&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity onPress=&#123;this._reload&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; &#125;, content: &#123; justifyContent: &apos;center&apos;, backgroundColor: &apos;yellow&apos;, &#125;, button: &#123; marginTop: 10, paddingVertical: 10, paddingHorizontal: 20, backgroundColor: &apos;black&apos; &#125;, buttonText: &#123; color: &apos;white&apos;, fontSize: 16, fontWeight: &apos;bold&apos;, &#125;&#125;) 留意这里我们用了 animateValue.setValue(1.5) 方法来修改动画属性值。 2、Animated.decay(animateValue, conf) —— 以一个初始速度开始并且逐渐减慢停止，conf参考： 1234&#123; velocity: 起始速度，必填参数。 deceleration: 速度衰减比例，默认为0.997。&#125; 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940let _animateHandler;export default class demo6 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; bounceValue : new Animated.Value(0.1) &#125;; &#125; componentDidMount() &#123; _animateHandler = Animated.decay(this.state.bounceValue, &#123; toValue: 0.2, velocity: 0.1 &#125;) &#125; _onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start() &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 30, transform: [&#123;scale: this.state.bounceValue&#125;]&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125; 对于最后介绍的两个动画效果，可能得熟悉一些物理、数学模型才能更好地来做控制，大部分情况下，咱们直接使用 Animated.timing 就足够满足需求了。 监听动画1、有时候我们需要在动画的过程中监听到某动画时刻的属性值，可以通过animateValue.stopAnimation(callback) 或 animateValue.addListener(callback) 来实现其中stopAnimation会停止当前动画并在回调函数中返回一个{value : number}对象，value对应最后一刻的动画属性值： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const _animateHandler, _isFirsPress = 0;export default class demo7 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; opacityAnmValue : new Animated.Value(0) //设置透明度动画初始值 &#125;; &#125; componentDidMount() &#123; _animateHandler = Animated.timing( this.state.opacityAnmValue, &#123; toValue: 1, duration: 6000, easing: Easing.linear &#125; ) &#125; _onPress() &#123; if(_isFirstPress === 0) &#123; _animateHandler.start &amp;&amp; _animateHandler.start(); _isFirsPress = 1 &#125; else &#123; this.state.opacityAnmValue.stopAnimation(value =&gt; &#123; Alert.alert( &quot;动画结束，最终值&quot;, JSON.stringify(value), [ &#123;text: &apos;OK&apos;, onPress: () =&gt; &#123;&#125;&#125; ] ) &#125;) &#125; &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View style=&#123;[styles.content, &#123;width: 200, height: 20, opacity: this.state.opacityAnmValue&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity &gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125; 而addListener方法会在动画的执行过程中调用callback回调函数，提供一个最近的值作为参数。 2、有时候我们希望在某个交互事件（特别是手势）中更灵活地捕获某个事件对象属性值，并动态赋予某个变量，对于这种需求可以通过 Animated.event 来实现。 它接受一个数组为参数，数组中的层次对应绑定事件参数的相应映射，听着有点绕，看例子就很好理解了： 12345678910111213var scrollX = 0, pan = &#123; x: 0, y: 0 &#125;;//...onScroll : Animated.event( [&#123;nativeEvent: &#123;contentOffset: &#123;x: scrollX&#125;&#125;&#125;] // scrollX = e.nativeEvent.contentOffset.x)onPanResponderMove : Animated.event([ null, // 忽略原生事件 &#123;dx: pan.x, dy: pan.y&#125; // 从gestureState中解析出dx和dy的值]); onScroll是绑定给某个组件的滚动事件，而onPanResponderMove是 PanResponder 模块下的响应事件。 拿上方onPanResponderMove的例子来讲，该事件方法接收两个参数 e 和 gestureState，其中gestureState的属性有： 12345678910stateID - 触摸状态的ID。在屏幕上有至少一个触摸点的情况下，这个ID会一直有效。moveX - 最近一次移动时的屏幕横坐标moveY - 最近一次移动时的屏幕纵坐标x0 - 当响应器产生时的屏幕坐标y0 - 当响应器产生时的屏幕坐标dx - 从触摸操作开始时的累计横向路程dy - 从触摸操作开始时的累计纵向路程vx - 当前的横向移动速度vy - 当前的纵向移动速度numberActiveTouches - 当前在屏幕上的有效触摸点的数量 来个简单的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class AwesomeProject extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; transY : new Animated.Value(0) &#125;; this._panResponder = &#123;&#125; &#125;componentWillMount处预先创建手势响应器 componentWillMount() &#123; this._panResponder = PanResponder.create(&#123; onStartShouldSetPanResponder: this._returnTrue.bind(this), onMoveShouldSetPanResponder: this._returnTrue.bind(this), //手势开始处理 //手势移动时的处理 onPanResponderMove: Animated.event([null, &#123; dy : this.state.transY &#125;]) &#125;); &#125; _returnTrue(e, gestureState) &#123; return true; &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h, transform: [&#123; translateY : this.state.transY &#125;] &#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125; &#123;...this._panResponder.panHandlers&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;control&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略此按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
</search>
