<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo 发布命令]]></title>
    <url>%2F2020%2F03%2F11%2Fhexo_01%2F</url>
    <content type="text"><![CDATA[1234567hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署每次发布时，使用 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[react 上传图片裁剪]]></title>
    <url>%2F2020%2F03%2F11%2Freact_03%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import Cropper from &quot;react-cropper&quot;;import &quot;cropperjs/dist/cropper.css&quot;;public cropperModal() &#123; return &lt;div className=&#123;styles[&quot;class-cropper-modal&quot;]&#125;&gt; &lt;div className=&#123;styles[&quot;modal-panel&quot;]&#125;&gt; &lt;div className=&#123;styles[&quot;cropper-container-container&quot;]&#125;&gt; &lt;div className=&#123;styles[&quot;cropper-container&quot;]&#125;&gt; &lt;Cropper src=&#123;this.state.src&#125; className=&quot;cropper&quot; ref=&quot;cropper&quot; viewMode=&#123;1&#125; movable=&#123;false&#125; zoomable=&#123;false&#125; // 是否允许放大图像 aspectRatio=&#123;1&#125; // 固定为1:1 可以自己设置比例, 默认情况为自由比例 guides=&#123;true&#125; background=&#123;false&#125; // 是否显示背景的马赛克 rotatable=&#123;false&#125; // 是否旋转 preview=&quot;.cropper-preview&quot; cropBoxResizable=&#123;false&#125; style=&#123;&#123; height: &quot;100%&quot;, width: CLIENTWIDTH &#125;&#125; /&gt; &lt;/div&gt; &lt;div className=&#123;styles[&quot;preview-container&quot;]&#125;&gt; &lt;div className=&#123;styles[&quot;cropper-preview&quot;]&#125; /&gt; &lt;/div&gt; &lt;div style=&#123;&#123; position: &quot;fixed&quot;, right: &quot;10px&quot;, top: &quot;10px&quot;, width: &quot;60px&quot;, height: &quot;30px&quot;, backgroundColor: &quot;rgb(255, 166, 54)&quot;, color: &quot;#fff&quot;, borderRadius: &quot;4px&quot;, display: &quot;flex&quot;, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot;, &#125;&#125; onClick=&#123;this.handleSubmit.bind(this)&#125;&gt; 保存 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;;&#125;public async handleSubmit() &#123; (this.refs.cropper as any).getCroppedCanvas().toBlob(async blob =&gt; &#123; // 上传操作 &#125;);&#125;.class-cropper-modal &#123; position: fixed; background-color: rgba(0, 0, 0, 0.3); top: 0; bottom: 0; left: 0; right: 0; display: flex; justify-content: center; align-items: center;&#125;.modal-panel &#123; width: 100%; height: 100%; background: white; display: flex; flex-direction: column; align-items: stretch;&#125;.cropper-container-container &#123; flex: 1; display: flex; align-items: stretch; justify-content: space-between; height: 100%;&#125;.cropper-container &#123; flex: 0 0 600px; margin-right: 20px;&#125;.cropper-container img &#123; width: 100%;&#125;.cropper &#123; width: 100%; height: 100%;&#125;.preview-container &#123; flex: 1; display: flex; align-items: flex-end;&#125;.cropper-preview &#123; width: 180px; height: 180px; overflow: hidden; border: 1px solid #383838;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js验证函数]]></title>
    <url>%2F2020%2F02%2F07%2Fjs_02%2F</url>
    <content type="text"><![CDATA[123456789// 判断手机号是否正确function isEffectPhone(phone: any) &#123; const reg = /^[1][3,4,5,6,7,8][0-9]&#123;9&#125;$/; if (!reg.test(phone)) &#123; return false; &#125; else &#123; return true; &#125;&#125; 1234// 判断传入时间是否大于当前实际时间export function contrastTime(start) &#123; return start.getTime() - new Date().getTime();&#125; 123456//获取屏幕宽度function getClientWidth() &#123; const width = (document.documentElement &amp;&amp; document.documentElement.clientWidth) ? document.documentElement.clientWidth : document.body.clientWidth; return (width &lt;= 1470);&#125; 1234截取字符串后几位function subStringEnd(string, n: number) &#123; return string.substring(string.length - n)&#125; 123456789101112// 根据数据获取所有值的和function getSum(arr, type?: string) &#123; let result = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if (type) &#123; result += (arr[i][type] * 1000); &#125; else &#123; result += arr[i]; &#125; &#125; return result / 1000;&#125; 1234// 隐藏手机号中间四位function getTel(tel: string) &#123; return tel.substring(0, 3) + &apos;****&apos; + tel.substring(tel.length - 4);&#125; 12345678910111213141516171819202122// 判断手机是iod/androidfunction checkPlatform() &#123; if (/android/i.test(navigator.userAgent)) &#123; // console.log(&quot;This is Android&apos;browser.&quot;);//这是Android平台下浏览器 return &apos;0&apos;; &#125; if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123; // console.log(&quot;This is iOS&apos;browser.&quot;);//这是iOS平台下浏览器 return &apos;1&apos;; &#125; if (/Linux/i.test(navigator.userAgent)) &#123; // console.log(&quot;This is Linux&apos;browser.&quot;);//这是Linux平台下浏览器 return &apos;2&apos;; &#125; if (/Linux/i.test(navigator.platform)) &#123; // console.log(&quot;This is Linux operating system.&quot;);//这是Linux操作系统平台 return &apos;2&apos;; &#125; if (/MicroMessenger/i.test(navigator.userAgent)) &#123; // console.log(&quot;This is MicroMessenger&apos;browser.&quot;);//这是微信平台下浏览器 &#125;&#125; 12345678// 生成随机的n位数function generateFiveRandomNum(n) &#123; let code = &apos;&apos;; for (let i = 0; i &lt; n+1; i++) &#123; code += Math.floor(Math.random() * 10); &#125; return code;&#125; 12345678// blob转base64function blobToDataURI(blob: any, callback: any) &#123; var reader = new FileReader(); reader.onload = function (e: any) &#123; callback(e.target.result); &#125; reader.readAsDataURL(blob);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js图片相关操作]]></title>
    <url>%2F2020%2F02%2F07%2Fjs_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718base64转Blobfunction base64ToBlob(base64) &#123; return new Promise(resolve =&gt; &#123; if (typeof base64 !== &quot;string&quot;) &#123; return resolve(base64); &#125; const bytes = window.atob(base64.split(&quot;,&quot;)[1]); // 处理异常，将ascii码小于0的转换为大于0 const buffer = new ArrayBuffer(bytes.length); const arr = new Uint8Array(buffer); for (let i = 0; i &lt; bytes.length; i++) &#123; arr[i] = bytes.charCodeAt(i); &#125; resolve(new Blob([buffer], &#123; type: &quot;image/jpeg&quot; &#125;)); &#125;);&#125; 12345678910111213base64转File public dataURLtoFile(dataurl, filename) &#123; // 将base64转换为文件 const arr = dataurl.split(&quot;,&quot;); const mime = arr[0].match(/:(.*?);/)[1]; const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123; type: mime &#125;);&#125; 12345678910111213base64转ArrayBuffer对象function base64ToArrayBuffer(base64) &#123; base64 = base64.replace(/^data\:([^\;]+)\;base64,/gmi, &quot;&quot;); const binary = atob(base64); const len = binary.length; const buffer = new ArrayBuffer(len); const view = new Uint8Array(buffer); for (let i = 0; i &lt; len; i++) &#123; view[i] = binary.charCodeAt(i); &#125; return buffer;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768获取图片的exif的角度function getOrientation(arrayBuffer) &#123; const dataView = new DataView(arrayBuffer); let length = dataView.byteLength; let orientation; let exifIDCode; let tiffOffset; let firstIFDOffset; let littleEndian; let endianness; let app1Start; let ifdStart; let offset; let i; // Only handle JPEG image (start by 0xFFD8) if (dataView.getUint8(0) === 0xFF &amp;&amp; dataView.getUint8(1) === 0xD8) &#123; offset = 2; while (offset &lt; length) &#123; if (dataView.getUint8(offset) === 0xFF &amp;&amp; dataView.getUint8(offset + 1) === 0xE1) &#123; app1Start = offset; break; &#125; offset++; &#125; &#125; if (app1Start) &#123; exifIDCode = app1Start + 4; tiffOffset = app1Start + 10; if (getStringFromCharCode(dataView, exifIDCode, 4) === &quot;Exif&quot;) &#123; endianness = dataView.getUint16(tiffOffset); littleEndian = endianness === 0x4949; if (littleEndian || endianness === 0x4D4D /* bigEndian */) &#123; if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) &#123; firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian); if (firstIFDOffset &gt;= 0x00000008) &#123; ifdStart = tiffOffset + firstIFDOffset; &#125; &#125; &#125; &#125; &#125; if (ifdStart) &#123; length = dataView.getUint16(ifdStart, littleEndian); for (i = 0; i &lt; length; i++) &#123; offset = ifdStart + i * 12 + 2; if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) &#123; // 8 is the offset of the current tag&apos;s value offset += 8; // Get the original orientation value orientation = dataView.getUint16(offset, littleEndian); // Override the orientation with its default value for Safari (#120) if (true) &#123; dataView.setUint16(offset, 1, littleEndian); &#125; break; &#125; &#125; &#125; return orientation;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ios图片旋转问题function rotateImg(img, direction, canvas) &#123; // 最小与最大旋转方向，图片旋转4次后回到原方向 // tslint:disable-next-line:variable-name const min_step = 0; // tslint:disable-next-line:variable-name const max_step = 3; if (img == null) &#123; return; &#125; const height = img.height; const width = img.width; let step = 2; if (step == null) &#123; step = min_step; &#125; if (direction === &quot;right&quot;) &#123; step++; // 旋转到原位置，即超过最大值 // tslint:disable-next-line:no-unused-expression step &gt; max_step &amp;&amp; (step = min_step); &#125; else &#123; step--; // tslint:disable-next-line:no-unused-expression step &lt; min_step &amp;&amp; (step = max_step); &#125; // 旋转角度以弧度值为参数 const degree = step * 90 * Math.PI / 180; const ctx = canvas.getContext(&quot;2d&quot;); switch (step) &#123; case 0: canvas.width = width; canvas.height = height; ctx.drawImage(img, 0, 0); break; case 1: canvas.width = height; canvas.height = width; ctx.rotate(degree); ctx.drawImage(img, 0, -height); break; case 2: canvas.width = width; canvas.height = height; ctx.rotate(degree); ctx.drawImage(img, -width, -height); break; case 3: canvas.width = height; canvas.height = width; ctx.rotate(degree); ctx.drawImage(img, -width, 0); break; &#125;&#125; 123456789// 判断图片大小function testMaxSize(size, maxSize) &#123; let isAllow = false; isAllow = size &lt;= maxSize; if (!isAllow) &#123; return false; &#125; return isAllow;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667旋转图片实际例子const reader = new FileReader();reader.readAsDataURL(file);reader.onload = () =&gt; &#123; dealImage(reader.result, file, 800, (data) =&gt; &#123; const size = this.testMaxSize(data.size, 1048576); if (!size) &#123; Message.error(&quot;图片过大,请上传小于1M的图片&quot;); return; &#125; &#125;)&#125;function dealImage(base64Url, files, w, bacllback) &#123; const newImage = new Image(); let orientation; orientation = getOrientation(base64ToArrayBuffer(base64Url)); newImage.src = base64Url; newImage.onload = async () =&gt; &#123; const canvas = document.createElement(&quot;canvas&quot;); if (orientation &amp;&amp; orientation !== 1) &#123; if (orientation === 6) &#123; this.rotateImg(newImage, &quot;left&quot;, canvas); this.yasuo(canvas.toDataURL(&quot;image/jpeg&quot;, 0.8), w, callback, files); &#125; else if (orientation === 8) &#123; this.rotateImg(newImage, &quot;right&quot;, canvas); this.yasuo(canvas.toDataURL(&quot;image/jpeg&quot;, 0.8), w, callback, files); &#125; else if (orientation === 3) &#123; this.rotateImg(newImage, &quot;right&quot;, canvas); this.rotateImg(newImage, &quot;right&quot;, canvas); this.yasuo(canvas.toDataURL(&quot;image/jpeg&quot;, 0.8), w, callback, files); &#125; &#125; else &#123; this.yasuo(base64Url, w, callback, files); &#125; &#125;;&#125;function yasuo(base64Url, w, callback, files) &#123; let imgWidth; let imgHeight; let blob: any; const img = new Image(); img.src = base64Url; img.onload = async () =&gt; &#123; imgWidth = img.width; imgHeight = img.height; const canvas = document.createElement(&quot;canvas&quot;); const ctx: any = canvas.getContext(&quot;2d&quot;); if (Math.max(imgWidth, imgHeight) &gt; w) &#123; if (imgWidth &gt; imgHeight) &#123; canvas.width = w; canvas.height = w * imgHeight / imgWidth; &#125; else &#123; canvas.height = w; canvas.width = w * imgWidth / imgHeight; &#125; &#125; else &#123; canvas.width = imgWidth; canvas.height = imgHeight; &#125; ctx.drawImage(img, 0, 0, canvas.width, canvas.height); blob = await this.dataURLtoFile(canvas.toDataURL(&quot;image/jpeg&quot;, 0.8), files.name); callback(blob); &#125;;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F10%2Fimmutable_01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[React Key对渲染的影响]]></title>
    <url>%2F2019%2F06%2F10%2Freact_02%2F</url>
    <content type="text"><![CDATA[12345678910使用React的开发版本时常会遇到这样的情况：渲染列表时，不为数组的每一项设置key，则控制台会警告，Warning：Each child in an array or iterator should have a unique &apos;key&apos; prop常有人为了消除警告，把数组的下标(index)作为key，但是当React渲染列表时，把数组的下标作为key时不正确的，它能做的，仅仅是消除告警而已，对渲染毫无帮助。React的key应该是稳定的，唯一的(只要在列表项中唯一就行)，把数组的下标作为key的缺点在于没有满足稳定性要求，推荐把id或者uuid等字段作为React的key，减少React对DOM操作]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[列表]]></title>
    <url>%2F2019%2F04%2F10%2Falg-01%2F</url>
    <content type="text"><![CDATA[12]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gitc撤销已经commit但是还没有push的代码]]></title>
    <url>%2F2019%2F04%2F09%2Fgit_01%2F</url>
    <content type="text"><![CDATA[123456789在git commit之后，正想着push，突然发现有些东西我们不想push上去这个时候我们想把提交的撤销掉，重新提交我们想提交的，push我们想要push的1、找到之前提交的git commit的idgit log 找到想要撤销的id2、git reset -hard id完成撤销，同时将代码恢复到前commit_id对应的版本，强制回滚到之前的版本3、git reset id完成撤销，停留在当前版本，不对代码修改进行撤销，可以直接通过git commit重新提交对本地代码的修改。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用nw.js打包react项目]]></title>
    <url>%2F2019%2F04%2F09%2Fface_02%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617nw.js原名node-webkit，它通过Chromium内核，可以在node环境下模拟浏览器运行时，因此可以将js封装成独立应用，从而实现跨平台。#### nw.js安装官方地址https://nwjs.io/，选择对应你自己的系统，开发的话可以下载SDK，SDK可以打开控制台，上线之类的可以选择Normal版本。#### 准备index.html文件将react项目build之后，将build目录下的文件拷贝到刚才下载的文件夹里面，和nw.exe同目录#### 准备package.json最后需要新建一个package.json文件，这是nw打包的配置文件和入口文件，最基础的是name，main&#123; name: &apos;nwDemo&apos;, main: &apos;index.html&apos;&#125;将package.json文件拷贝到nw.exe同目录下，运行nw.exe即可]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用React和face-api.js提供面部识别]]></title>
    <url>%2F2019%2F03%2F21%2Fface_01%2F</url>
    <content type="text"><![CDATA[12345678 face-api.js提供了Tiny Face Detector、SSD mobileNet和MTCNN三种模型，此API人脸识别的原理就是一旦检测到一个或多个人脸，人脸检测器模型将返回每个人脸的边界框，告诉我们人脸在图像中的位置。然后利用人脸标志网络对人脸标志进行68个点的标记，在人脸识别网络进行输入前，利用对齐模型确定人脸的中心位置。 人脸识别网络是另一个神经网络返回一个人脸描述符（特征向量包含128个值），我们可以用它来比较和识别图像中的人。就像指纹一样，脸部描述符是每个脸部的独特价值。当我们比较它们时，来自不同图像源的同一个人的人脸描述符应该非常接近。在这个项目中，我们使用欧几里德距离进行比较。如果距离小于我们设定的阈值，我们确定他们可能是同一个人。 （距离越远，信心越高） 通常，系统将每个人的面部描述符与他或她的名称一起存储为标记。当我们提供查询图像时，系统会将新图像的脸部描述符与所有参考描述符进行比较，并识别具有最低图像描述符的人。如果没有比较低于阈值的人，则该人将被识别为未知。 12今天这里实现两个功能。一种是从输入图像中识别，另一种是使用实时视频作为输入。让我们从create-react-app开始，安装react-router-dom，然后启动App 123456create-react-app face-democd face-demoyarn add react-router-domyarn start这时会自动打开默认的页面 1将src/App.js文件用react-router-dom设置一下]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React生命周期]]></title>
    <url>%2F2019%2F01%2F15%2Freact_01%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223react的生命周期分为四个阶段：初始化阶段、更新阶段、销毁阶段、错误处理阶段#### 初始化阶段- constructor- static getDerivedStateFromProps- componentWillMount()- render- componentDidmount()#### 更新阶段- componentWillReceiveProps- static getDerivedStateFromprops()- shouldComponentUpdate()- componentWillUpdate()- render()- getSnapshotBeforeUpdate()- componentDidUpdate()#### 销毁阶段- compinentWillUnmount()#### 错误处理- componentDidCatch() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546初始化阶段详细#### constructor //自动执行，一开始就会执行React组件的构造函数在挂载之前被调用。在实现React.Component构造函数时，需要现在添加其他内容前，调用super(props)，用来将父组件传来的props绑定到这个类中，使用this.props将会得到。步子啊这里生命或者执行事件constructor中应当做些初始化的动作，如：初始化state，将时间绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。#### static getDerivedStateFromProps(nextprops) //自动执行，必须有返回值，输出参数为新值getDerivedStateFromProps是react16.3之后新增，在组件实例化后，和接受新的props后被调用。他必须返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。调用setState()不会触发getDerivedStateFromProps()之前这里都是使用constructor + componentWillRecieveProps完成相同的功能的#### componentWillMount() //render()前调用，可以直接修改state自动执行，即将挂载组件componentWillMount()将在React未来版本中被弃用，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。这个方法因为是在渲染之前被调用，也是唯一一个可以直接同步修改state的地方#### render() //直接执行，必须要有的，一般返回html代码render()方法是必需的。当他被调用时，他将计算this.props和this.state，并返回以下一种类型：1、React元素。通过jsx创建，既可以时dom元素，也可以是用户自定义的组件。2、字符串或数字。他们将会以文本节点形式渲染到dom中3、Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。4、null，什么也不渲染5、布尔值。也是什么都不渲染。当返回null，false，ReactDOM.findDOMNode(this)将会返回null，什么都不会渲染render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。如果shouldComponentUpdate()返回false，render()不会被调用。#### componentDidMount() //直接执行，可以在这里进行网络请求，第三方实例化，拿到真实dom，写死的数据可以直接写在这里，如果是获取到的会变得数据，则需要使用定时器，不要的话函数一直再触发，会导致更新不了视图，需要在dom元素更新完之后执行componentDidMount在组件被装配后立即调用。初始化使得DOM节点应该进行到这里 123456789101112131415161718192021222324252627282930313233343536373839更新阶段#### componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps) //改变state或者props时触发官方建议使用getDerivedStateFromProps函数替代此函数。当组件挂载后，接收到新的props后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用this.setState()如果父组件会让这个组件重新渲染，即使props没有改变，也会调用这个方法React不会在组件初始化props时调用这个方法。调用this.setState也不会触发#### shouldComponentUpdate(nextprops, nextstate) //参数为新的状态和属性，如果返回值为false，状态改变，视图不更新，数据改变时触发，性能优化的方法之一调用shouldComponentUpdate使React知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。在渲染新的props或state前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在forceUpdate()时被调用。返回false不会阻止子组件在state更改时重新渲染。如果shouldComponentUpdate()返回false，componentWillUpdate,render和componentDidUpdate不会被调用UNSAFE_componentWillUpdate(nextprops, nextstate) //渲染新的数据时调用在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。在这里改变数据会导致死循环，这个函数没有太大的实际作用不能在这里使用this.setStae()，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedFromProps.#### getsnapshotBeforeUpdate() //新的数据渲染前调用，可以记录scroll滚动条在react render()后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate()#### componentDidUpdate( prevprops,prevstate,snapshot )//第三个参数来自getSnapshopBeforeUpdate()函数的返回值 1234567891011121314151617销毁阶段componentWillUnmount()// 连dom结构都会清除掉在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount中创建的任何监听componentDidCatch(err, info)出错时页面不会崩溃，但是会在控制台输出错误错误边界是React组件，可以在其子组件树中的任何位置捕获js错误，记录这些错误并显示回退ui，而不是崩溃的组件树。错误边界在渲染期间生命周期方法以及整个树下的构造函数中捕获错误。如果类组件定义了此生命周期方法，则它将成错误边界。在它中调用setState()可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复; 不要试图将它们用于控制流程。错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决bootstrap模态框切换时页面抖动or页面滚动条]]></title>
    <url>%2F2019%2F01%2F15%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[Bootstrap为了让所有的页面(这里指内容溢出和不溢出)显示效果一样，采取的方法如下: 当Modal显示时，设置 1234body &#123; overflow: hidden; margin-right: 15px&#125; (设置15px是因为浏览器的滚动条占位时15px) 在modal显示时给body添加 1234.modal-open &#123; overflow: auto; overflow-y: scroll;&#125; 这样设置的效果是： 1、当页面内容超出(即页面本身存在滚动条)，则modal弹出后，原body滚动禁止，body的margin-right和modal的滚动条位置重叠，此时页面是不会出现抖动现象的。2、当页面内容未超出(即页面本身不存在滚动条)，则modal弹出后，由于body设置了margin-right，会使得页面向左偏移，当modal关闭后，body的margin-right为0，页面向右偏移，就出现页面抖动。 根据上面的描述，解决页面抖动的思路是： 根据scrollHeight和clientHeight，分别在modal加载前和关闭时调整body的overflow、margin-right和.modal的overflow属性，以覆盖bootstrap.css中的样式 函数如下： 1234//解决Modal弹出时页面左右移动问题最佳的办法应该是CSS：引用@僵叔叔的答案：body&#123; overflow: auto !important;&#125; .modal&#123; overflow: auto !important;&#125;]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac显示隐藏文件]]></title>
    <url>%2F2019%2F01%2F15%2Fmac_01%2F</url>
    <content type="text"><![CDATA[第一种：在macOS Sierra, 我们可以使用快捷键⌘⇧.(Command + Shift + .)来快速(在Finder中)显示和隐藏文件 第二种在终端使用： 1234//显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true//不显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超过固定宽度(或行数)显示...(或省略)]]></title>
    <url>%2F2019%2F01%2F15%2Fcss_02%2F</url>
    <content type="text"><![CDATA[作为前端经常遇到的一个需求。对于一些比较长的文本做限制，不显示，或者显示省略号。今天整理一下。 1、超出固定长度显示…123456.class &#123; width: 400px; overflow: hidden; //这个是设置隐藏的。还有其他的，例如scroll，是超出固定长度，底部显示滚动条的。 text-overflow: ellipsis; //这个就是设置直接隐藏掉文字，还是显示...的。当前是显示省略号，直接省略是clip。 display: inline-block; //根据不同标签display值，有的不用加&#125; 2、超出固定行数显示…超出固定行数。显示省略号，和上面差不多。overflow和text-overflow见上方解释。 1234567.class &#123; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; //这里就是设置超出几行隐藏 -webkit-box-orient: vertical; display: -webkit-box; //根据不同标签display，有的不用加。或者设置成别的属性，自己可以随便试试&#125; 巨坑提醒(多行隐藏)有的时候，你按照上面的设置。就是不生效。或者本地生效了，react（或者vue）打包到服务器上就不生效了。你可以在控制台看看。是不是-webkit-box-orient这个属性消失了。如果是这样的话，请看下面的解决方法。 12345678910111213//办法1直接在style里面写上display: -webkit-box; 就行//办法2.class &#123; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; /* autoprefixer: off */ //对，就是加这两个注释就行. -webkit-box-orient: vertical; /* autoprefixer: on */ display:-webkit-box;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css3隔行变色]]></title>
    <url>%2F2019%2F01%2F15%2Fcss_01%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657div:nth-of-type(odd)&#123;background:#fff&#125; /*奇数行*/div:nth-of-type(even)&#123;background:#000&#125; /*偶数行 */div:nth-child(4n+1)&#123;background:#fff&#125; /*从第一行开始算起 每隔四个（包含第四个）使用此样式*/div:nth-child(4n+2)&#123;background:#fff&#125; /*从第二行开始算起 每隔四个（包含第四个）使用此样式*/&lt;strong&gt;E:nth-child(n)&lt;/strong&gt;找出E元素,且它是你北朝鲜绵第n个子元素.n可以是数字(1,2,3),关键字(odd,even),公式(2n,2n+3),数字是从1开始的,不是0.如:tr:nth-child(3)匹配所有表格里第3行的trtr:nth-child(2n+1)匹配所有表格的奇数行tr:nth-child(2n)匹配所有的偶数行tr:nth-child(odd)匹配所有的奇数行tr:nth-child(even)匹配所有的偶数行&lt;strong&gt;E:nth-last-child(n)&lt;/strong&gt;选择E元素,且它是父元素的倒数第n个子元素&lt;strong&gt;E:nth-of-type(n)&lt;/strong&gt;选择E元素,且它是父元素所有子元素中类型为E的子元素集合中的第n个,n可以是数字(1,2,3),关键字(odd,even),公式(2n,2n+3),数字是从1开始的,不是0.如p:nth-of-type(2)匹配出,&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;中第二个p元素&lt;strong&gt;E:nth-last-of-type(n)&lt;/strong&gt;选择E元素,且它是父元素的倒数第n个子节点&lt;strong&gt;E:last-child&lt;/strong&gt;找出E元素,且它是父元素中的最后一个字节点&lt;strong&gt;E:first-of-tpe&lt;/strong&gt;找出E元素,且它是父元素中是第一个该类型的元素,如p:first-of-type匹配&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;中的第一个p元素.&lt;strong&gt;E:last-of-type&lt;/strong&gt;找出E元素,且它是父元素中的最后一个该类型的元素.如:p:last-of-type匹配,&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;中的最后一个p元素,它同E:nth-last-of-tpe(1)意义相同&lt;strong&gt;E:only-child&lt;/strong&gt;找出父元素中只包括一个的子元素,且该元素是E&lt;strong&gt;E:only-of-type&lt;/strong&gt;选择其父元素只包含一个同类型的子元素,且该子元素匹配E.如p:only-of-type匹配&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;中的p,因为div中只包括一个p元素&lt;strong&gt;E:empty&lt;/strong&gt;匹配E元素,且该元素不包含子节点,注意,文字也属于节点]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android版本名称、版本号、API level对应关系]]></title>
    <url>%2F2019%2F01%2F15%2Fandroid_01%2F</url>
    <content type="text"><![CDATA[- Code name Version API level 1 no code name 1.0 API level 1 2 no code name 1.1 API level 2 3 Cupcake 1.5 API level 3,NDK 1 4 Donut 1.6 API level 4,NDK 2 5 Eclair 2.0 API level 5 6 Eclair 2.0.1 API level 6 7 Eclair 2.1 API level 7,NDK3 8 Froyo 2.2.x API level 8,NDK 4 9 Gingerbread 2.3-2.3.2 API level 9,NDK5 10 Gingerbread 2.3.3-2.3.7 API level 10 11 Honeycomb 3.0 API level 11 12 Honeycomb 3.1 API level 12,NDK 6 13 Honeycomb 3.2x API level 13 14 Ice Cream Sandwich 4.0.1-4.0.2 API level 14,NDK 7 15 Ice Cream Sandwich 4.0.3-4.0.4 API level 15,NDK 8 16 Jelly Bean 4.1x API level 16 17 Jelly Bean 4.2x API level 17 18 Jelly Bean 4.3x API level 18 19 Jelly Bean 4.4-4.4.4 API level 19 20 Lollipop 5.0 API level 21 21 Lollipop 5.1 API level 22 22 Marshmallow 6.0 API level 23 23 Nougat 7.0 API level 24 24 Nougat 7.1.1 API level 25]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Naitve 性能优化]]></title>
    <url>%2F2019%2F01%2F15%2Frn_01%2F</url>
    <content type="text"><![CDATA[1、利用shouldComponentUpdate函数优化react性能以及引入immutable库的必要性(也适用于react-native)123setState()函数在任何情况下都会导致组件重渲染吗？如果setState()中参数还是原来没有发生任何变化的staten？如果组件的state没有变化，并且从父组件接收的props也没有变化，那它就一定不会重渲染吗？如果1，2两种情况下都会导致重渲染，我们该如何避免这种冗杂的操作，从而优化性能？ 参考 https://www.cnblogs.com/penghuwan/p/6707254.html]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Native解决'libgnustl_shared.so is 32-bit instead if 64-bit'报错]]></title>
    <url>%2F2019%2F01%2F15%2Frn_02%2F</url>
    <content type="text"><![CDATA[React Native项目在64位Android手机上运行，会提示“/data/data/com.xxx.xxx/lib-main/libgnustl_shared.so”is 32-bit instead of 64-bit这个错误。 解决方法就是取消掉所有64位的.so文件，全部加载32位的就可以了，下面是步骤 在项目的根部录的gradle.properties里面添加一行代码，android.useDeprecatedNdk = true. 在build.gradle文件里添加以下代码： 12345678910111213android &#123; ... defaultConfig &#123; ... ndk &#123; abiFilters: &quot;armeabi-v7a&quot;,&quot;x86&quot; &#125; packagingOptions &#123; exclude &quot;lib/arm64-v8a/librealm-jni.so&quot; &#125; &#125;&#125;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Naitve 错误集锦]]></title>
    <url>%2F2019%2F01%2F15%2Frn_03%2F</url>
    <content type="text"><![CDATA[1、在android华为手机上运行React-native工程时出现了如下错: 1报错：unable to load script from assets &apos;index.android.bundle&apos;, make sure your bundle is packaged correctly or youu’re running a packager server 解决办法： 1、在Android/app/src/main目录下创建一个空的assets文件夹 2、进入项目跟目录执行下面代码: 1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/ 1运行完毕后assets文件夹下会多出index.android.bundle和index.android.bundle.meta两个文件 重新运行 总结:index.android.bundle是用来调用原生控件的js脚本，每次当改变index.android.js,都需要使用上面的代码片段，来及时的更新index.android.bundle文件，然后打包才可以把新的index.android.js应用上，所以没有index.android.bundle文件时，React-Native项目时无法运行的。]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端开发自适应解决方案（阿里团队高清方案）]]></title>
    <url>%2F2019%2F01%2F15%2Fmobile_01%2F</url>
    <content type="text"><![CDATA[移动端自适应方案有很多1、流式布局 也就是固定高度，宽度是用百分比的方法，这种方法会导致一些元素在大屏手机上拉伸严重的情况，影响视觉效果，只有在很少一部分手机上能完美的展示设计师想要的效果。 2、固定宽度做法 比如早期的淘宝webpage，页面设置成320的宽度，超出部分留白，在大屏幕手机上，就会出现两条大白边，分辨旅高的手机，页面看起来就会特别小，按钮，文字也很小。 3、响应式做法 用一些css框架，比如bootstrap，或者juqeryUI，使用媒体查询，这种方式维护成本高，很少有大型网站使用这种布局。 4、设置viewport进行缩放 天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。不过有时候使用过程中缩放会导致有些页面元素会糊。 5、rem布局 rem是css3新引入的单位，在pc端会有兼容问题，对移动端比较友好。简而言之就是通过动态设置html跟元素的fontsize，等比缩放元素大小来自适应移动设备。 1234567891011121314151617181920212223242526272829303132333435! function(e) &#123; function t(a) &#123; if (i[a]) return i[a].exports; var n = i[a] = &#123; exports: &#123;&#125;, id: a, loaded: !1 &#125;; return e[a].call(n.exports, n, n.exports, t), n.loaded = !0, n.exports &#125; var i = &#123;&#125;; return t.m = e, t.c = i, t.p = &quot;&quot;, t(0)&#125;([function(e, t) &#123; &quot;use strict&quot;; Object.defineProperty(t, &quot;__esModule&quot;, &#123; value: !0 &#125;); var i = window; t[&quot;default&quot;] = i.flex = function(e, t) &#123; var a = e || 100, n = t || 1, r = i.document, o = navigator.userAgent, d = o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i), l = o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i), c = l &amp;&amp; parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;), 10) &gt;= 80, p = navigator.appVersion.match(/(iphone|ipad|ipod)/gi), s = i.devicePixelRatio || 1; p || d &amp;&amp; d[1] &gt; 534 || c || (s = 1); var u = 1 / s, m = r.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;); m || (m = r.createElement(&quot;meta&quot;), m.setAttribute(&quot;name&quot;, &quot;viewport&quot;), r.head.appendChild(m)), m.setAttribute(&quot;content&quot;, &quot;width=device-width,user-scalable=no,initial-scale=&quot; + u + &quot;,maximum-scale=&quot; + u + &quot;,minimum-scale=&quot; + u), r.documentElement.style.fontSize = a / 2 * s * n + &quot;px&quot; &#125;, e.exports = t[&quot;default&quot;]&#125;]);flex(100, 1); 代码原理1、根据设备屏幕的DPR(设备像素比，比如dpr=2时，表示一个css像素由2x2个物理像素点组成)动态设置html的font-size。2、同事根据设备DPR调整页面的缩放值，进而达到高清效果。 方案优势1、引用简单，方便布局(只要把js代码贴到head标签里面，就可以使用了，设计稿一般是640或者750，不需要进行单位换算，直接用设计稿的尺寸就可以，比如设计稿又一个btn的高度为80px，宽度为120px，高清方案默认1rem=100px，那么btn的宽度就设置为:) 1234.btn &#123; width: 0.8rem, height: 1.2rem&#125; 2、根据设备屏幕的DPR，自动设置最合适的高清缩放。保证了不同设备视觉体验的一致性。3、有效解决移动端真是1px问题(这里的1px是设备屏幕上的物理像素) 1234567注意：并不是所有用px的地方都要用rem，rem布局只针对固定宽度。依需求而定，比如淘宝页面底下的tabar，和头部的搜索区域，都是用百分比来布局的，或者flex和模型，当在ipad上打开的时候就可以看见，头部和tab是撑满全屏的。中间的主要内容（最外部的容器）要设置一个max-width，demo设置的是max-width：10rem，这里我不太明白为什么要设置成10rem，有弄明白的小伙伴希望能告诉我。谢谢（已解决，和设置最外层宽度为100%是一样的道理，10rem 可以适配到所有手机设备。1000%可以适配ipad，demo试试就知道了）（应用了此方案，不管设计图多宽（当然，一般宽度为750，640也可以），最外层的div宽度设为100%就行，然后就可以愉快的布局了，不会出现你说的白边的情况。）对于尺寸比较大的元素，应该考虑用百分比。rem做单位的元素在哪种设备下都是固定大小，这点必须牢记！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657可能遇到的问题：1.问：为啥手机网页效果图宽度是要640或者750的，我非得弄个666的不行咩？答：老实说当然可以，不过为了规范，640或者750是相对合适的。拿Iphone 5s 举例，它的css像素宽度是320px，由于它的dpr=2，所以它的物理像素宽度为320 × 2 = 640px，这也就是为什么，你在5s上截了一张图，在电脑上打开，它的原始宽度是640px的原因。那 iphone 6 的截图宽度呢？ 375 × 2 = 750那 iphone 6 sp 的截图宽度呢？ 414 × 3 = 1242以此类推，你现在能明白效果图为什么一般是 640 ，750 甚至是 1242 的原因了么？（真没有歧视安卓机的意思。。。）2.问：宽度用rem写的情况下， 在 iphone6 上没问题， 在 iphone5上会有横向滚动条，何解？答：假设你的效果图宽度是750，在这个效果图上可能有一个宽度为7rem（高清方案默认 1rem = 100px）的元素。我们知道，高清方案的特点就是几乎完美还原效果图，也就是说，你写了一个宽度为 7rem 的元素，那么在目前主流移动设备上都是7rem。然而，iphone 5 的宽度为640，也就是6.4rem。于是横向滚动条不可避免的出现了。怎么办呢？ 这是我目前推荐的比较安全的方式：如果元素的宽度超过效果图宽度的一半（效果图宽为640或750），果断使用百分比宽度，或者flex布局。就像把等屏宽的图片宽度设为100%一样。3.问：不是 1rem = 100px吗，为什么我的代码写了一个宽度为3rem的元素，在电脑端的谷歌浏览器上宽度只有150px?答：先说高清方案代码，再次强调咱们的高清方案代码是根据设备的dpr动态设置html 的 font-size，如果dpr=1(如电脑端），则html的font-size为50px，此时 1rem = 50px如果dpr=2(如iphone 5 和 6），则html的font-size为100px，此时 1rem = 100px如果dpr=3(如iphone 6 sp），则html的font-size为150px，此时 1rem = 150px如果dpr为其他值，即便不是整数，如3.4 , 也是一样直接将dpr 乘以 50 。再来说说效果图，一般来讲，我们的效果图宽度要么是640，要么是750，无论哪一个，它们对应设备的dpr=2，此时，1 rem = 50 × 2 = 100px。这也就是为什么高清方案默认1rem = 100px。而将1rem默认100px也是好处多多，可以帮你快速换算单位，比如在750宽度下的效果图，某元素宽度为53px，那么css宽度直接设为53/100=0.53rem了。然而极少情况下，有设计师将效果图宽定为1242px，因为他手里只有一个iphone 6 sp (dpr = 3)，设计完效果图刚好可以在他的iphone 6 sp里查看调整。一切完毕之后，他将这个效果图交给你来切图。由于这个效果图对应设备的dpr=3，也就是1rem = 50 × 3 = 150px。所以如果你量取了一个宽度为90px的元素，它的css宽度应该为 90/150=0.6rem。由于咱们的高清方案默认1rem=100px，为了还原效果图，你需要这样换算。当然，一个技巧就是你可以直接修改咱们的高清方案的默认设置。在代码的最后 你会看到 flex(100, 1) ，将其修改成flex(66.66667, 1)（感谢简友：V旅行指出此处错误！ 2017/3/24）就不用那么麻烦的换算了，此时那个90px的直接写成0.9rem就可以了。4.问：高清方案在微信上，有时候字体会不受控制变的很大，怎么办？答：点我，这是我对该问题的总结5.问：我在底部导航用的flex感觉更合适一些，请问这样子混着用可以吗？答：咱们的rem适合写固定尺寸。其余的根据需要换成flex或者百分比。源码示例中就有这三种的综合运用。6.问：在高清方案下，一个标准的，较为理想的宽度为640的页面效果图应该是怎样的？7.这个会和bootstrap冲突。解决办法：1，将bootstrap 中，凡是用到px的单位一律换成rem2，如果你有使用webpack，建议使用将css转成rem的包（postcss-pxtorem）将自动完成第一步的操作。8.@2x和@3x的图片还要判断不同的dpr下用不同的图片。Normalize.css 是一个可以定制的CSS文件，它让不同的浏览器在渲染网页元素的时候形式更统一。Normalize.css 能干什么：保留有用的默认值，不同于许多 CSS 的重置标准化的样式，适用范围广的元素。纠正错误和常见的浏览器的不一致性。一些细微的改进，提高了易用性。使用详细的注释来解释代码。支持的浏览器：Google Chrome (latest)Mozilla Firefox (latest)Mozilla Firefox ESROpera (latest)Apple Safari 6+Internet Explorer 8+ 引用于https://www.jianshu.com/p/07669cb3e7c5]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Native动画]]></title>
    <url>%2F2019%2F01%2F15%2Frn_04%2F</url>
    <content type="text"><![CDATA[前言最近项目要做小游戏，小游戏当然就少不了动画了，一开始打算用h5做，但是考虑到内嵌h5坑可能有点多，所以最后还是选择react native的动画（项目本身就是react native写的，之后用rn代表react naitve） 1、requestAnimationFrame12345678910111213141516171819202122232425262728293031323334353637383940414243444546export default class demo1 Component &#123; constructor(props) &#123; super(props); this.state = &#123; width: 100, height: 100 &#125;; &#125; startAnimation() &#123; let count = 0; let &#123; width, height &#125; = this.state; requestAnimationFrame(() =&gt; &#123; this.setState(&#123; widthL: width + 1, height: height + 1 &#125;) &#125;) &#125; render() &#123; let &#123; width, height &#125; = this.state; return( &lt;View style = &#123; styles.container &#125;&gt; &lt;Image source = &#123;require(./icon.jpg)&#125; style = &#123;&#123; width: width, height: height &#125;&#125; /&gt; &lt;TouchableOpacity style = &#123; styles.instructions &#125; onPress = &#123;()=&gt;this.startAnimation()&#125; &gt; &lt;Text style = &#123;&#123; alignSelf: &apos;center&apos;, color: &apos;#fff&apos; &#125;&#125;&gt; click me! &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 这个方式实现的动画有几个问题： 实现方式是通过不断销毁、创建视图来完成，一方面如果你的视图的数据是动态获取的，那么就需要以合适的方式恢复数据；另一方面，这种方式必然造成性能和内存开销的问题。 如果需要刷新的View的层级比较深，那么这种方式会带来严重的性能问题。 requestAnimationFrame毕竟是web上css的用法，在手机上，动画的效果比较生硬，如果需要‘弹性动画’，‘淡入淡出’等效果，则是比较难以实现的（需要辅助各种函数）。 2、setNativeProps 如果执意使用修改state的方式，觉得这种方式更符合当前需求对动画的控制，那么则应当使用原生组件的setNativeProps方法来做对应实现，它会直接修改组件底层特性，会重绘组件，因此性能也远胜动态修改组件内联style的方法。我们稍微修改下startAnimation方法： 12345678910111213startAnimation() &#123; var count = 0; while (++count &lt; 50) &#123; requestAnimationFrame(() = &gt;&#123; this.refs.image.setNativeProps(&#123; style: &#123; width: this.state.width++, height: this.state.height++ &#125; &#125;); &#125;); &#125;&#125; 其中this.refs.image指向的是image视图，效果比上面的好多了。 优点：setNativeProps直接修改组件底层特性，不会重绘组件，因此性能也远胜动态修改组件内联style的方法。 缺点： setNativeProps属于原生视图的方法，如果我们使用一个动画，单纯只是为了跟踪它的值，那么这个方法有点不合时宜。 还是和上面一种方式一样，如果需要实现‘弹性动画’，‘淡入淡出’等效果，则还是比较麻烦的。 3、LayoutAnimation当布局变化时，自动将视图运动到它们新的位置上。一个常用的调用此API的办法是调用LayoutAnimation.configureNext(config)，然后调用setState。其中conf参数格式参考： 1234567891011&#123; duration: 700, //持续时间 create: &#123; //若是新布局的动画类型 type: &apos;linear&apos;, //线性模式 property: &apos;opacity&apos; //动画属性，除了opacity还有一个scaleXY可以配置 &#125;, update: &#123; //若是布局更新的动画类型 type: &apos;spring&apos;, //弹跳模式 springDamping: 0.4 //弹跳阻尼系数 &#125;&#125; 其中动画type的类型可枚举为： 123456spring //弹跳linear //线性easeInEaseOut //缓入缓出easeIn //缓入easeOut //缓出keyboard // 键入 要注意的时，安卓平台使用LayoutAnimation动画必须加上这么一句代码(否则动画会失效): 1UIManager.setLayoutAnimationEnabledExperimental &amp;&amp; UIManager.setLayoutAnimationEnabledExperimental(true); 于是我们一开始的动画就可以这么来写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export default class demo2 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; w: 200, h: 20 &#125;; &#125; _onPress() &#123; LayoutAnimation.configureNext(&#123; duration: 700, create: &#123; type: &apos;linear&apos;, property: &apos;opacity&apos; &#125;, update: &#123; type: &apos;spring&apos;, springDamping: 0.4 &#125; &#125;); this.setState(&#123; w: this.state.w + 30, h: this.state.h + 30 &#125;) &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125; &#125; 这样动画灵活和流畅多了，我们上面看到的仅仅是局部更新的情况，我们来看看新布局被创建（有新组建加入到视图上）的情况如何： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default class demo3 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; showNewOne: false, w: 200, h: 20 &#125;; &#125; _onPress() &#123; LayoutAnimation.configureNext(&#123; duration: 1200, create: &#123; type: &apos;linear&apos;, property: &apos;opacity&apos; //注意这里，我们设置新布局被创建时的动画特性为透明度 &#125;, update: &#123; type: &apos;spring&apos;, springDamping: 0.4 &#125; &#125;); this.setState(&#123;w: this.state.w + 30, h: this.state.h + 30, showNewOne : true&#125;) &#125; render() &#123; let &#123; showNewOne &#125; = this.state; let newOne = showNewOne ? ( &lt;View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;new one&lt;/Text&gt; &lt;/View&gt; ) : null; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/View&gt; &#123;newOne&#125; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 4、Animated通过Animated我们可以在确保性能良好的前提下创造更为灵活丰富且易维护的动画。不同于上述的动画实现方式，我们得在 Animated.View、Animated.Text 或 Animated.Image 动画组件上运用 Animate 模块的动画能力(如果有在其他组件上的需求，可以使用Animated.createAnimatedComponent方法来对其它类型的组件创建动画)下面来个简单的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Easing, Animated, TouchableOpacity,&#125; from &apos;react-native&apos;const _animateHandler;export default class demo4 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; opacityAnmValue: new Animated.Value(0) &#125;; &#125; componentDidMount() &#123; _animateHandler = Animated.timing( this.state.opacityAnmValue, &#123; toValue: 1, //透明度动画最终值 duration: 3000, easing: Easing.bezier(0.15,0.73,0.37,1.2) //缓冲函数 &#125; ) &#125; _onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start() &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 20, opacity: this.state.opacityAnmValue&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity &gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; &#125;, content: &#123; justifyContent: &apos;center&apos;, backgroundColor: &apos;yellow&apos;, &#125;, button: &#123; marginTop: 10, paddingVertical: 10, paddingHorizontal: 20, backgroundColor: &apos;black&apos; &#125;, buttonText: &#123; color: &apos;white&apos;, fontSize: 16, fontWeight: &apos;bold&apos;, &#125;&#125;) 点击按钮后,Animated.View会以bezier曲线形式执行时长3秒的透明度动画(由0到1): 1、以 new Animated.Value(0) 实例化动画的初始值给state： 1234this.state = &#123; //设置透明度动画初始值 opacityAnmValue: new Animated.Value(0)&#125; 2、通过 Animated.timing 我们定义了一个动画事件，在后续可以以 .start() 或 .stop() 方法来开始/停止该动画： 1234567componentDidMount() &#123; _animateHandler = Animated.timing(this.state.opacityAnmValue, &#123; toValue: 1, //透明度动画最终值 duration: 3000, //动画时长3000毫秒 easing: Easing.bezier(0.15, 0.73, 0.37, 1.2) &#125;)&#125; 我们在点击事件中触发了动画的.start方法让它跑起来: 123_onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start()&#125; start 方法接受一个回调函数，会在动画结束时触发，并传入一个参数 {finished: true/false}，若动画是正常结束的，finished 字段值为true，若动画是因为被调用 .stop() 方法而提前结束的，则 finished 字段值为false。 3、动画的绑定是在 上的，我们把实例化的动画初始值传入 style 中： 123&lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 20, opacity: this.state.opacityAnmValue&#125;]&#125;&gt;&lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt;&lt;/Animated.View&gt; 然后。。。就没有然后了，很简单吧。 这里需要讲一下的应该是定义动画事件的Animated.timing(animateValue, conf) 方法，其中设置参数格式为： 12345&#123; duration: 动画持续的时间（单位是毫秒），默认为500。 easing：一个用于定义曲线的渐变函数。阅读Easing模块可以找到许多预定义的函数。iOS默认为Easing.inOut(Easing.ease)。 delay: 在一段时间之后开始动画（单位是毫秒），默认为0。&#125; 这里提及的 Easing 动画函数模块在 react-native/Libraries/Animated/src/ 目录下，该模块预置了 linear、ease、elastic、bezier 等诸多缓动特性，有兴趣可以去了解。 另外除了 Animated.timing，Animated 还提供了另外两个动画事件创建接口： 1、Animated.spring(animateValue, conf) —— 基础的单次弹跳物理模型，支持origami标准，conf参考： 1234&#123; friction: 控制“弹跳系数”、夸张系数，默认为7。 tension: 控制速度，默认40。&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Easing, Animated, TouchableOpacity,&#125; from &apos;react-native&apos;let _animateHandler;export default class demo5 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; bounceValue : new Animated.Value(0) //设置缩放动画初始值 &#125;; &#125; componentDidMount() &#123; this.state.bounceValue.setValue(1.5); // 设置一个较大的初始值 _animateHandler = Animated.spring(this.state.bounceValue, &#123; toValue: 1, friction: 8, tension: 35 &#125;) &#125; _onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start() &#125; _reload() &#123; AppRegistry.reload() &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 20, transform: [&#123;scale: this.state.bounceValue&#125;]&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity onPress=&#123;this._reload&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; &#125;, content: &#123; justifyContent: &apos;center&apos;, backgroundColor: &apos;yellow&apos;, &#125;, button: &#123; marginTop: 10, paddingVertical: 10, paddingHorizontal: 20, backgroundColor: &apos;black&apos; &#125;, buttonText: &#123; color: &apos;white&apos;, fontSize: 16, fontWeight: &apos;bold&apos;, &#125;&#125;) 留意这里我们用了 animateValue.setValue(1.5) 方法来修改动画属性值。 2、Animated.decay(animateValue, conf) —— 以一个初始速度开始并且逐渐减慢停止，conf参考： 1234&#123; velocity: 起始速度，必填参数。 deceleration: 速度衰减比例，默认为0.997。&#125; 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940let _animateHandler;export default class demo6 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; bounceValue : new Animated.Value(0.1) &#125;; &#125; componentDidMount() &#123; _animateHandler = Animated.decay(this.state.bounceValue, &#123; toValue: 0.2, velocity: 0.1 &#125;) &#125; _onPress() &#123; _animateHandler.start &amp;&amp; _animateHandler.start() &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View ref=&quot;view&quot; style=&#123;[styles.content, &#123;width: 200, height: 30, transform: [&#123;scale: this.state.bounceValue&#125;]&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125; 对于最后介绍的两个动画效果，可能得熟悉一些物理、数学模型才能更好地来做控制，大部分情况下，咱们直接使用 Animated.timing 就足够满足需求了。 监听动画1、有时候我们需要在动画的过程中监听到某动画时刻的属性值，可以通过animateValue.stopAnimation(callback) 或 animateValue.addListener(callback) 来实现其中stopAnimation会停止当前动画并在回调函数中返回一个{value : number}对象，value对应最后一刻的动画属性值： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const _animateHandler, _isFirsPress = 0;export default class demo7 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; opacityAnmValue : new Animated.Value(0) //设置透明度动画初始值 &#125;; &#125; componentDidMount() &#123; _animateHandler = Animated.timing( this.state.opacityAnmValue, &#123; toValue: 1, duration: 6000, easing: Easing.linear &#125; ) &#125; _onPress() &#123; if(_isFirstPress === 0) &#123; _animateHandler.start &amp;&amp; _animateHandler.start(); _isFirsPress = 1 &#125; else &#123; this.state.opacityAnmValue.stopAnimation(value =&gt; &#123; Alert.alert( &quot;动画结束，最终值&quot;, JSON.stringify(value), [ &#123;text: &apos;OK&apos;, onPress: () =&gt; &#123;&#125;&#125; ] ) &#125;) &#125; &#125; render() &#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View style=&#123;[styles.content, &#123;width: 200, height: 20, opacity: this.state.opacityAnmValue&#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity onPress=&#123;this._onPress&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Press me!&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity &gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略本按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125; 而addListener方法会在动画的执行过程中调用callback回调函数，提供一个最近的值作为参数。 2、有时候我们希望在某个交互事件（特别是手势）中更灵活地捕获某个事件对象属性值，并动态赋予某个变量，对于这种需求可以通过 Animated.event 来实现。 它接受一个数组为参数，数组中的层次对应绑定事件参数的相应映射，听着有点绕，看例子就很好理解了： 12345678910111213var scrollX = 0, pan = &#123; x: 0, y: 0 &#125;;//...onScroll : Animated.event( [&#123;nativeEvent: &#123;contentOffset: &#123;x: scrollX&#125;&#125;&#125;] // scrollX = e.nativeEvent.contentOffset.x)onPanResponderMove : Animated.event([ null, // 忽略原生事件 &#123;dx: pan.x, dy: pan.y&#125; // 从gestureState中解析出dx和dy的值]); onScroll是绑定给某个组件的滚动事件，而onPanResponderMove是 PanResponder 模块下的响应事件。 拿上方onPanResponderMove的例子来讲，该事件方法接收两个参数 e 和 gestureState，其中gestureState的属性有： 12345678910stateID - 触摸状态的ID。在屏幕上有至少一个触摸点的情况下，这个ID会一直有效。moveX - 最近一次移动时的屏幕横坐标moveY - 最近一次移动时的屏幕纵坐标x0 - 当响应器产生时的屏幕坐标y0 - 当响应器产生时的屏幕坐标dx - 从触摸操作开始时的累计横向路程dy - 从触摸操作开始时的累计纵向路程vx - 当前的横向移动速度vy - 当前的纵向移动速度numberActiveTouches - 当前在屏幕上的有效触摸点的数量 来个简单的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class AwesomeProject extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; transY : new Animated.Value(0) &#125;; this._panResponder = &#123;&#125; &#125;componentWillMount处预先创建手势响应器 componentWillMount() &#123; this._panResponder = PanResponder.create(&#123; onStartShouldSetPanResponder: this._returnTrue.bind(this), onMoveShouldSetPanResponder: this._returnTrue.bind(this), //手势开始处理 //手势移动时的处理 onPanResponderMove: Animated.event([null, &#123; dy : this.state.transY &#125;]) &#125;); &#125; _returnTrue(e, gestureState) &#123; return true; &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Animated.View style=&#123;[styles.content, &#123;width: this.state.w, height: this.state.h, transform: [&#123; translateY : this.state.transY &#125;] &#125;]&#125;&gt; &lt;Text style=&#123;[&#123;textAlign: &apos;center&apos;&#125;]&#125;&gt;Hi, here is VaJoy&lt;/Text&gt; &lt;/Animated.View&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125; &#123;...this._panResponder.panHandlers&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;control&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;忽略此按钮&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
</search>
